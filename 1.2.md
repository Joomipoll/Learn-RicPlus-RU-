# Команды препроцессора
## Препроцессор
Препроцессор — это текстовый процессор, который обрабатывает текст исходного файла на первом этапе перевода.
Препроцессор не анализирует исходный текст, а разбивает его на маркеры для обнаружения вызовов макросов.
Хотя компилятор обычно вызывает препроцессор при первом проходе, препроцессор также может быть вызван отдельно для обработки текста без его компиляции.

## Директивы препроцессора
Директивы препроцессора обычно используются для упрощения изменения и компиляции исходных программ в разных средах выполнения.
Директивы в исходном файле говорят препроцессору выполнять определенные действия.
Например, препроцессор может заменить токены в тексте, внедрить содержимое других файлов в файл исходного кода или отключить компиляцию части файла, удалив фрагменты текста.
Строки препроцессора распознаются и выполняются до раскрытия макроса.
Таким образом, если макрос превращается во что-то похожее на команду препроцессора, он не распознает его.

Препроцессор распознаёт следующие директивы:
- [#install](#1)
- [#namespace](#2)
- [#linkf](#3)
- [#using](#4)
- [#if, #else, #elif, #endif](#5)
- [#error](#6)

### <a name="1">#install</a>

Используется для подлючения библиотек

Синтаксис: `#install имя_встроенной_библиотеки`, либо:
```
#install имя_сторонней_библиотеки
    import 'путь/до_сторонней/библиотеки' либо net'протокол://сайт'
```
`#install` может принимать значения, такие как: `import`

**"import"** нужен для указания пути к заданной библиотеке, если речь идёт об импорте других, не встроенных в язык библиотек.
"import" может использоваться для импорта из какого-либо веб-ресурса, либо может указывать на директорию, где распологается установленная библиотека.

### <a name="2">#namespace</a>

Используется для создания пространства имён. Пишется в главном файле проекта rcn

Синтаксис:
```C++
#namespace MyNamespace

MyNamespace
[
// code
]
```

Принимает значения "Имя" для письма множества пространств имён в одном файле
```C++
#namespace MyNamespace1
#namespace MyNamespace2

MyNamespace1
[
say("Hello, world!");
]
MyNamespace2
[
say("Hello, programmer!");
]
```
Пространство имён не может быть объявлено внутри другого пространства имён!

### <a name="3">#linkf</a>

Альтернатива директивы #install, но директива #linkf используется для включения содержимого указанного файла

Синтаксис: `#linkf <пространство_имён_в_проекте>`

### <a name="4">#using</a>

Используется для сокращения названий библиотек. Синтаксис:
```
#install исходное_название_библиотеки;
#using исходное_название_библиотеки -> короткое_название_библиотеки;
```

Например:
```
#install ооченьдлинноеназваниебиблиотекикотораячтотоделает;
#using ооченьдлинноеназваниебиблиотекикотораячтотоделает -> простолиба;

простолиба.простофункция(простоеёпараметры);
```

### <a name="5">#if, #else, #elif, #endif</a>

Это почти то же самое, что и конструкция if...else, но с использованием специальных условий и с приоритетностью (то есть будут выполняться в первую очередь)

Синтаксис:
```C++
#if условие
Выполняемый код
#elif условие
Выполняемый код
#else
Выполняемый код
#endif  // Конец конструкции
```

Приведём пример:

Файл param.rcn:
```C++
#namespace PrintHW

PrintHW
[
#if const x
#install put
string hw = "Hello, world!";
#endif
]
```

Файл main.rcn:
```C++
#linkf <PrintHW>

const x;
say(hw);    // Hello, world!
```

Файл Hello.cfg
```YAML
Main:
    Output: false
    Name: Hello
    Langv: 6.0
    Packages:
        - name: rc+
          version: 1.3.0
Def:
    File: "param.rcn"
```

### <a name="6">#error</a>

Директива `#error` выдает указанное пользователем сообщение об ошибке во время компиляции, а затем завершает компиляцию.

Пример:
```C++
#if config(langv, packages = [name = "rc+", version]) >= config(langv = "6.0", packages = [name = "rc+", version = "1.3.0"])
/*
    Если в конфигурации проекта указана версия языка и/или пакета больше,
    чем 6.0 и 1.3.0,
    либо равно этим значениям,
    то выполнится переход к исполению файла main.rcn
*/
goto file'main.rcn';
#elif config(langv, packages = [name = "rc+", version]) < config(langv = "6.0", packages = [name = "rc+", version = "1.3.0"])
/*
    Иначе если версии языка и пакета меньше,
    чем 6.0 и 1.3.0,
    то выполнится прерывание
*/
#error "Ошибка: Версия языка и/или пакета, указанного в конфигурации не соответствует коду"
#endif
```

Однако данная директива бесполезна и её мало используют.
