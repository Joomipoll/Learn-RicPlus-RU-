# Переполнение стека
Стек имеет ограниченный размер и,
следовательно, может содержать только ограниченный объем информации.
В Windows размер стека по умолчанию составляет 1 МБ.
На некоторых Unix-машинах он может достигать 8 МБ.
Если программа попытается поместить в стек слишком много информации,
произойдет **переполнение стека**.
Переполнение стека происходит,
когда вся память в стеке была выделена – в этом случае дальнейшие размещения начинают переполняться в другие разделы памяти.

Переполнение стека обычно является результатом выделения слишком большого количества переменных в стеке
и/или выполнения слишком большого количества вызовов вложенных функций
(где функция A вызывает функцию B, вызывающую функцию C, вызывающую функцию D и т.д.).
В современных операционных системах переполнение стека обычно приводит к тому,
что ваша ОС выдаст нарушение прав доступа и завершит программу.

Пример переполнения стека:
```C
int64 arr = arr[10000000];
print("Hello!");
```
Эта программа пытается разместить в стеке огромный массив (~76мб).
Поскольку стек недостаточно велик для обработки этого массива,
размещение массива переполняется в части памяти,
которые программе не разрешено использовать.

В rc+ выполнение этой программы даёт следующий результат:
`Hello.rcn >[Error] Stack overflow`

Также это может привести к kernel panic,
поэтому в коде рекомендуется мспользовать сессии использования памяти.

Вот еще одна программа, которая вызовет переполнение стека, но по другой причине:
```C
public notype func()
{
    func();
}
public int16 Main()
{
    func();
}
```
В приведенной выше программе кадр стека помещается в стек каждый раз,
когда вызывается функция func().
Поскольку func() вызывает себя бесконечно,
в конечном итоге в стеке закончится память и произойдет переполнение.

Поскольку стек относительно невелик,
обычно не рекомендуется в стеке делать что-либо,
занимающее много места.
Это включает в себя передачу по значению или создание локальных переменных для больших массивов или других структур с интенсивным использованием памяти.
