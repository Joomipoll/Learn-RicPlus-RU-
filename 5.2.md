# Полиморфизм

Полиморфизм - способность функции обрабатывать данные разных типов

Существует несколько разновидностей полиморфизма. Две принципиально различных из них были описаны Кристофером Стрэчи в 1967 году: это параметрический полиморфизм и ad-hoc-полиморфизм, прочие формы являются их подвидами или сочетаниями. Параметрический полиморфизм является истинным, т.к. подразумевает исполнение одного и того же кода для всех допустимых типов аргументов, а ad-hoc-полиморфизм — мнимым, т.к. представляет собой обеспечение косметической однородности потенциально разного исполнимого кода для каждого конкретного типа аргумента. При этом существуют ситуации, где необходимо использование именно ad-hoc-полиморфизма, а не параметрического[. Теория квалифицированных типов объединяет все виды полиморфизма в единую модель.

Если параметру функции сопоставлен ровно один тип, то такая функция называется мономорфной. Многие языки программирования предоставляют синтаксический механизм для назначения нескольким мономорфным функциям единого имени (идентификатора). В этом случае, в исходном коде становится возможным осуществлять вызов функции с фактическими параметрами разных типов, но в скомпилированном коде фактически происходит вызов различных функций. Стрэчи назвал такую возможность «ad-hoc-полиморфизмом». 

Если параметру функции сопоставлено более одного типа, то такая функция называется полиморфной. Разумеется, с каждым фактическим значением может быть связан лишь один тип, но полиморфная функция рассматривает параметры на основе внешних свойств, а не их собственной организации и содержания. Стрэчи назвал такую возможность «параметрическим полиморфизмом». 

В дальнейшем классификацию уточнил Лука Карделли, выделив четыре разновидности полиморфизма: <br>
- универсальный
    - параметрический
    - включения
- ad-hoc
    - перегрузка
    - приведение типов

В некоторых работах параметрический, ad-hoc- и полиморфизм подтипов выделяются как три самостоятельных класса полиморфизма

## Ad-hoc-полиморфизм 

Поддерживается посредством перегрузки функций

В следующем примере функции Add выглядят как реализующие одну и ту же функциональность над разными типами, но компилятор определяет их как две совершенно разные функции:
```C++
overload public int16 Add((x, y)_int16 | float)
{
    say(x + y);
}

public int16 Main()
{
    Add(10, 3);     // 13
    Add(0.2, 0.6);  // 0.8
}
```
